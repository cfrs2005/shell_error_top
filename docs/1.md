# for i in $(ls *.mp3)


太多程序员写shell的时候在循环中犯的错误


```
for i in $(ls *.mp3); do    # Wrong!
    some command $i         # Wrong!
done

for i in $(ls)              # Wrong!
for i in `ls`               # Wrong!

for i in $(find . -type f)  # Wrong!
for i in `find . -type f`   # Wrong!

files=($(find . -type f))   # Wrong!
for i in ${files[@]}        # Wrong!
```

确实,这样写让你很容易得到当前目录下所有文件,并快速使用.但是你不能这样做,实际上这个命令开始的时候就已经错了,可以这么说,获取当前文件这个事情没有太多技巧可言,在文件列入循环过程中你需要使用其他方法。


这其中至少有5个问题需要关注:

- 如果一个文件的名字有空格组成,空格会造成字符分割,假如说我们有个文件名字为:   01 - Don't Eat the Yellow Snow.mp3 的文件在当前目录下，当前这个循环会将这个文件名 遍历出来一个新的数组 : : 01, -, Don't, Eat....

- 如果文件的名字存在使用**全局**字符串,他将作为全局变量被引用.如果包含＊ 字符串,那么他隐式的去匹配当前符合条件内容一起存储列表

- 如果当前命令会返回多个文件名,这里就没有办法告诉你谁是第一个谁是最后一个文件,没有起始结束.路径可能会包含Null以外的字符串。当然这包含换行符.


- ls 命令可能会压缩文件名字.这取决于你使用哪个平台,哪个参数被使用(或者未使用),命令结果是否是标准终端输出或者不是，ls 命令支持使用"?"匹配某些字符,或者你根本不需要打印她们.不要尝试解析ls的输出结果


- ls命令看上去就像获取所有当前路径的文件名字，增加换行符号输出。但实际上如果文件名字是换行符 ,...或者是$() 将会被移除掉.如果文件开始就是一个链接符号,那么它将会是陷阱


你不能简单的去使用双引号去替换命令,比如:

```
for i in "$(ls *.mp3)"; do # Wrong!
```

这将导致ls获取的文件名，都被转成1个字符串，这样做不是去递归每个文件名,当前循环只会执行一次,将只会返回一个字符串,包含了所有的文件名的一行字符串.


当然你也不能通过IFS去更改换行符,文件名字允许使用换行符作为字.


当前这个问题的可能产生一些其他问题如: 分词 或者 循环(不正确的)读取文件行.例如:



```
IFS=$'\n'
for line in $(cat file); do ...     # Wrong!
```
她将不会工作!除非文件名有换行符的文件.Bash(其他shell加醋成员)一般都不会支持这类工作。

如上述情况,使用ls是一个不是很明智的行为.ls是一个外部命令，是用于人读取使用，而不是用语shell操作.


那么如何正确使用呢 ？

让我们用一个简单的命令来实现吧:

```
find . -type f -exec some command {} \;
```
通过这样就不需要ls也可以实现你需要的功能,


```
for i in ./*.mp3; do    # Better! and...
    some command "$i" # ...always double-quote expansions!
done
```

POSIX shell工具提供了全局参数调用,使bash具有功强大的功能-允许shell将扩展为可以匹配文件名列表的功能.它没有必要去打印出程序的结果。因为全局的扩展作用，所以能够精确的匹配mp3的单词，并且不会因为扩展符号影响(如果你需要递归处理,参见find功能或者shopt -s 或者更高版本 bash4中的应用)


问题:

如果没有匹配到*.mp3的文件在当前目录会发生什么?当前循环只会执行一次,"./*.mp3"这个结果不是预期想要的！解决方法是匹配是否有文件存在:

```
for i in ./*.mp3; do
    [ -e "$i" ] || continue
    some command "$i"
done
```

应外一个建议是实用 bash中的 shopt -s 功能,透过这个可以轻松的读取的文档目录,并且在这之后应用如何使用.

注意上面 $i的使用，这将是我们第二节的内容，这也会是个陷阱.


